Исправления

AccommodationsProcessor:

1. Добавил проверки на корректность дат, ID пользователя и валюты в методе ProcessCommand, тем самым избавился от Parse, заменив на TryParse в проверках выше. 
2. Так же добавил проверку даты, во избежании бронирования номера задним числом или на текущее.
3. Создание брони поместил в конструкцию Try Catch (на всякий случай)
4. В методе Undo добавил проверку на наличие прошлых команд, чтобы нельзя было отменить несуществующую команду.

BookingService:

1. В методе Book добавил проверку, чтобы дата отъезда не только не была раньше даты заезда, но и еще не была ей.
2. В методе CalculateCancellationPenaltyAmount исправил ошибку деления на 0.

"int daysBeforeArrival = (DateTime.Now - booking.StartDate).Days" здесь идет вычитание даты заезда из текущей.
Однако, DateTime.Now содержит не только число, но и теущее время. booking.StartDate имеет время по умолчанию 00:00:00, по этому в случае вычитания, результат будет меньше одного дня.
Для исправления просто прибавим 1 к результату вычитания.

3. В методе GetCurrencyRate убрал рандомный курс, заменив на фиксированный.
4. В методе CalculateBookingCost исправил формулу вычисления скидки. (Логичнее было бы давать скидку, основываясь на категории номера, а не ID пользователя. Чем дороже категория - тем больше скидка)

FindBookingByIdCommand:

1. Для корректного вывода нужно было написать booking.RoomCategory.Name

Непонятно зачем у объекта пользователя есть имя-фамилия, если они никак не используются. Может так надо, и это на потом, но логичнее было бы при поиске брони отображать
имя пользователя, а не его ID.


Процесс фильтрации

1. Создадим несколько броней:

book 1 Deluxe 23.04.2025 24.05.2025 rub
book 2 Standard 24.04.2025 24.07.2025 usd
book 3 Deluxe 26.04.2025 24.08.2025 usd
book 4 Standard 27.04.2025 24.09.2025 cny
book 5 Deluxe 29.04.2025 24.12.2025 cny 

2. Поставим точку останова в BookingService, метод SearchBookings, 99 строка.

3. Напишем команду search 22.04.2025 24.06.2025 Deluxe (Ищем такие брони, которые находятся в данном промежутке и категория Deluxe)

4. Создается список всех наших броней
IQueryable<Booking> query = _bookings.AsQueryable();

5. Затем, отфильтровываются те, у кого дата заезда больше введенной даты
query = query.Where(b => b.StartDate >= startDate);

В нашем случае, они все больше, по этому список остался неизменным.

6. После этого убираются все брони, у которых дата отъезда больше введенной даты

query = query.Where(b => b.EndDate < endDate);

7. И финальный фильтр - остаются только те, у кого нужная категория комнаты

query = query.Where(b => b.RoomCategory.Name == categoryName);

8. На выход мы получаем все брони, которые соответствуют нашему запросу.

return query.ToList();

Вот что выводится на консоль:

Found 1 bookings for category 'Deluxe' between 22.04.2025 0:00:00 and 24.06.2025 0:00:00:
- Booking ID: b1775955-8b7f-4394-b263-dbf86970649c, User ID: 1
